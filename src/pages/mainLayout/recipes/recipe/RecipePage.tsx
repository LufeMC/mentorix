import { useContext, useEffect, useRef, useState } from 'react';
import Navbar from '../../../../components/navbar/Navbar';
import styles from './RecipePage.module.scss';
import { FirebaseContext } from '../../../../contexts/firebase-context';
import { useNavigate, useParams } from 'react-router-dom';
import RecipeService from '../../../../services/recipe.service';
import { Recipe, recipeRedirects } from '../../../../types/recipe';
import Step from './components/step/Step';
import RecipeDetails from './components/details/Details';
import { BsBookmarkFill, BsBookmark } from 'react-icons/bs';
import { LuShare } from 'react-icons/lu';
import { AlertContext } from '../../../../contexts/alert-context';
import { Alert, alertTypes } from '../../../../stores/alertStore';
import { RecipesAtom } from '../../../../stores/recipesStore';
import { useAtom } from 'jotai';
import { UserAtom } from '../../../../stores/userStore';
import { logEvent } from 'firebase/analytics';

export default function RecipePage() {
  const firebaseContext = useContext(FirebaseContext);
  const alertContext = useContext(AlertContext);
  const { recipeId } = useParams();
  const navigate = useNavigate();
  const [user, setUser] = useAtom(UserAtom);
  const [recipes, setRecipes] = useAtom(RecipesAtom);

  const [recipe, setRecipe] = useState<Recipe>();

  const contentRef = useRef<HTMLDivElement | null>(null);
  const logging = useRef<boolean>(false);

  useEffect(() => {
    if (recipeId) {
      getRecipe(recipeId);
    }

    if (!logging.current) {
      logging.current = true;
      logEvent(firebaseContext.analytics, 'recipe_open');
      logging.current = false;
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [recipeId]);

  useEffect(() => {
    if (contentRef.current && window.innerWidth <= 700) {
      contentRef.current.scrollTop = -contentRef.current.scrollHeight;
    }
  }, [recipe]);

  const getRecipe = async (recipeId: string) => {
    const savedRecipe = recipes!.find((recipe) => recipe.id === recipeId);
    // const recipeGenerated = window.sessionStorage.getItem('recipeGenerated');

    if (!savedRecipe) {
      const newRecipe = await RecipeService.getRecipeById(firebaseContext.firestore, recipeId);

      if (typeof newRecipe === 'string') {
        alertHandler("This recipe doesn't exist", 'warning');

        navigate('/');
      }
      // else if (
      //   (!recipeGenerated || recipeGenerated !== recipeId) &&
      //   (!shareId || (typeof newRecipe !== 'undefined' && shareId !== newRecipe.shareId))
      // ) {
      //   alertHandler("This recipe wasn't saved to your account or generated by you", 'warning');

      //   navigate('/');
      // } else if (typeof newRecipe !== 'undefined' && (shareId === newRecipe.shareId || recipeGenerated === recipeId)) {
      //   setRecipe(newRecipe);
      //   redirectActions(newRecipe);
      // }
      else if (typeof newRecipe !== 'undefined') {
        setRecipe(newRecipe);
        redirectActions(newRecipe);
      }
    } else {
      setRecipe(savedRecipe);
      redirectActions(savedRecipe);
    }
  };

  const redirectActions = async (recipe: Recipe) => {
    const action = window.sessionStorage.getItem('action') as keyof typeof recipeRedirects;

    if (action) {
      switch (action) {
        case 'share': {
          shareRecipe(recipe);
          break;
        }
        case 'bookmark': {
          bookmarkRecipe(recipe);
          break;
        }
      }
    }

    window.sessionStorage.removeItem('action');
  };

  const redirectToAuth = (recipeId: string, action: keyof typeof recipeRedirects) => {
    alertHandler('Please, login or signup to continue', 'warning');

    window.sessionStorage.setItem('recipeId', recipeId);
    window.sessionStorage.setItem('action', action);
    navigate('/auth');
  };

  const alertHandler = (text: string, type: keyof typeof alertTypes) => {
    const newAlert: Alert = {
      message: text,
      type,
    };
    alertContext.startAlert(newAlert);
  };

  const shareRecipe = (newRecipe?: Recipe) => {
    RecipeService.shareRecipe(alertHandler, newRecipe, recipe);
  };

  const bookmarkRecipe = async (newRecipe?: Recipe) => {
    if (!user) {
      redirectToAuth(recipe!.id, 'bookmark');
    } else {
      if (user.premium) {
        navigate('/recipes');
      } else {
        await RecipeService.bookmarkRecipe(
          firebaseContext.firestore,
          user,
          setUser,
          recipes,
          setRecipes,
          newRecipe,
          recipe,
        );
      }
    }
  };

  const unbookmarkRecipe = async () => {
    if (user) {
      redirectToAuth(recipe!.id, 'share');
    } else {
      await RecipeService.unBookmarkRecipe(firebaseContext.firestore, user, setUser, recipes, setRecipes, recipe);
    }
  };

  return (
    <div className={styles.recipe}>
      <Navbar darkSchema={true} />
      {recipe && (
        <div ref={contentRef} className={styles.content}>
          <div className={styles.instructionsContainer}>
            <h1>{recipe.title}</h1>
            <div className={styles.instructions}>
              <h2>Instructions</h2>
              <div className={styles.steps}>
                {recipe.instructions.map((instruction, index) => (
                  <Step text={instruction} step={index + 1} key={instruction} />
                ))}
              </div>
            </div>
          </div>
          <div className={styles.details}>
            <h1>{recipe.title}</h1>
            <RecipeDetails recipe={recipe} />
            <div className={styles.actions}>
              {user && user.recipes.includes(recipe.id) ? (
                <BsBookmarkFill onClick={() => unbookmarkRecipe()} />
              ) : (
                <BsBookmark onClick={() => bookmarkRecipe()} />
              )}
              <LuShare onClick={() => shareRecipe()} />
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
