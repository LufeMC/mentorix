import { useContext, useEffect, useState } from 'react';
import Navbar from '../../navbar/Navbar';
import styles from './RecipePage.module.scss';
import { FirebaseContext } from '../../../../contexts/firebase-context';
import { useNavigate, useParams } from 'react-router-dom';
import RecipeService from '../../../../services/recipe.service';
import { Recipe, recipeRedirects } from '../../../../types/recipe';
import Step from './components/step/Step';
import useRecipesStore from '../../../../stores/recipesStore';
import RecipeDetails from './components/details/Details';
import { BsBookmarkFill, BsBookmark } from 'react-icons/bs';
import { LuShare } from 'react-icons/lu';
import useUserStore from '../../../../stores/userStore';
import { AlertContext } from '../../../../contexts/alert-context';
import { Alert, alertTypes } from '../../../../stores/alertStore';
import UserService from '../../../../services/user.service';
import { copyOrShareText } from '../../../../utils/share';

export default function RecipePage() {
  const firebaseContext = useContext(FirebaseContext);
  const alertContext = useContext(AlertContext);
  const { recipeId } = useParams();
  const navigate = useNavigate();
  const recipesStore = useRecipesStore();
  const userStore = useUserStore();

  const [recipe, setRecipe] = useState<Recipe>();

  useEffect(() => {
    if (recipeId) {
      getRecipe(recipeId);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [recipeId]);

  const getRecipe = async (recipeId: string) => {
    const savedRecipe = recipesStore!.recipes!.find((recipe) => recipe.id === recipeId);
    const recipeGenerated = window.sessionStorage.getItem('recipeGenerated');

    if (!savedRecipe) {
      const newRecipe = await RecipeService.getRecipeById(firebaseContext.firestore, recipeId);

      if (typeof newRecipe === 'string') {
        const newAlert: Alert = {
          message: "This recipe doesn't exist",
          type: 'warning',
        };
        alertContext.setAlert(newAlert);

        navigate('/');
      } else if (!recipeGenerated || recipeGenerated !== recipeId) {
        const newAlert: Alert = {
          message: "This recipe wasn't saved to your account or generated by you",
          type: 'warning',
        };
        alertContext.setAlert(newAlert);

        navigate('/');
      } else if (typeof newRecipe !== 'undefined') {
        setRecipe(newRecipe);
        redirectActions(newRecipe);
      }
    } else {
      setRecipe(savedRecipe);
      redirectActions(savedRecipe);
    }
  };

  const redirectActions = async (recipe: Recipe) => {
    const action = window.sessionStorage.getItem('action') as keyof typeof recipeRedirects;

    if (action) {
      switch (action) {
        case 'share': {
          shareRecipe(recipe);
          break;
        }
        case 'bookmark': {
          bookmarkRecipe(recipe);
          break;
        }
      }
    }

    window.sessionStorage.removeItem('action');
  };

  const redirectToAuth = (recipeId: string, action: keyof typeof recipeRedirects) => {
    const newAlert: Alert = {
      message: 'Please, login or signup to continue',
      type: 'warning',
    };
    alertContext.setAlert(newAlert);
    window.sessionStorage.setItem('recipeId', recipeId);
    window.sessionStorage.setItem('action', action);
    navigate('/auth');
  };

  const alertHandler = (text: string, type: keyof typeof alertTypes) => {
    const newAlert: Alert = {
      message: text,
      type,
    };
    alertContext.setAlert(newAlert);
  };

  const shareRecipe = (newRecipe?: Recipe) => {
    if (!userStore || !userStore.user) {
      redirectToAuth(recipe!.id, 'share');
    } else {
      copyOrShareText(
        `Check out the recipe for ${newRecipe ? newRecipe.title : recipe?.title}:\n${window.location.href}/${
          newRecipe ? newRecipe.shareId : recipe?.shareId
        }\nTo create more recipes like this, visit https://cookii.io`,
        alertHandler,
      );
    }
  };

  const bookmarkRecipe = (newRecipe?: Recipe) => {
    if (!userStore || !userStore.user) {
      redirectToAuth(recipe!.id, 'bookmark');
    } else {
      const currentUser = structuredClone(userStore.user);
      currentUser.recipes.push(newRecipe ? newRecipe.id : recipe!.id);
      UserService.updateUser(firebaseContext.firestore, currentUser, userStore);
      recipesStore.addRecipe(newRecipe ? newRecipe : (recipe as Recipe));
    }
  };

  const unbookmarkRecipe = () => {
    if (!userStore || !userStore.user) {
      redirectToAuth(recipe!.id, 'share');
    } else {
      const currentUser = structuredClone(userStore.user);
      currentUser.recipes = currentUser.recipes.filter((recipeId) => recipeId !== recipe!.id);
      UserService.updateUser(firebaseContext.firestore, currentUser, userStore);
      recipesStore.removeRecipe(recipe!.id);
    }
  };

  return (
    <div className={styles.recipe}>
      <Navbar darkSchema={true} />
      {recipe && (
        <div className={styles.content}>
          <div className={styles.instructionsContainer}>
            <h1>{recipe.title}</h1>
            <div className={styles.instructions}>
              <h2>Instructions</h2>
              <div className={styles.steps}>
                {recipe.instructions.map((instruction, index) => (
                  <Step text={instruction} step={index + 1} key={instruction} />
                ))}
              </div>
            </div>
          </div>
          <div className={styles.details}>
            <RecipeDetails recipe={recipe} />
            <div className={styles.actions}>
              {userStore && userStore.user && userStore.user.recipes.includes(recipe.id) ? (
                <BsBookmarkFill onClick={() => unbookmarkRecipe()} />
              ) : (
                <BsBookmark onClick={() => bookmarkRecipe()} />
              )}
              {((userStore && userStore.user && userStore.user.recipes.includes(recipe.id)) ||
                window.sessionStorage.getItem('recipeGenerated') === recipe.id) && (
                <LuShare onClick={() => shareRecipe()} />
              )}
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
